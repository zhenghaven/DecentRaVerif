(* This library is used for verifying DecentRA (distributed enclave application)
framework implemented with SGX.
 	Author: Haofan Zheng
*)

(* NOTE: Defs begin with CV_ are derived from cryptoverif.pvl, in order to
provide potential bridges to CryptoVerif.
	Credits to the author(s) of cryptoverif.pvl. *)

(*============================================================================*)
(*****************************   CV Defs Starts  ******************************)

(***************************** CV_Common_Declarations ******************************)

def CV_Common_Declarations(bitstringbot, bottom, emptyStr, keyseed, cleartext, ciphertext) {
	type bitstringbot.
	const bottom:bitstringbot.

	const emptyStr : bitstring.

	type keyseed.
	type cleartext.
	type ciphertext.
}

(***************************** CV_DSA ******************************)

def CV_det_signature_types(spkey, sskey, signinput, signature) {
	type sskey.
	type spkey.
	type signinput.
	type signature.
}

def CV_det_signature_args(keyseed, spkey, sskey, signinput, signature, sskgen, spkgen, sign, checksign) {

fun sign(signinput, sskey): signature.
fun sskgen(keyseed):sskey.
fun spkgen(keyseed):spkey.

fun checksign(signinput, spkey, signature): bool
reduc forall m:signinput, r:keyseed;
	checksign(m, spkgen(r), sign(m, sskgen(r))) = true
otherwise forall m: signinput, pk: spkey, s: signature;
        checksign(m, pk, s) = false.

reduc forall m:signinput, r:keyseed;
        getmess(sign(m, sskgen(r))) = m.

reduc forall m:signinput, r:keyseed;
        getkey(sign(m, sskgen(r))) = spkgen(r).

}

(***************************** CV_RSA ******************************)

def CV_public_key_enc_types(pkey, skey, aenc_seed) {
	type pkey.
	type skey.
	type aenc_seed.
}

def CV_public_key_enc_args(keyseed, bitstringbot, bottom, pkey, skey, cleartext, ciphertext, aenc_seed, skgen, pkgen, aenc, aenc_r, adec, injbot, Z) {

fun aenc_r(cleartext, pkey, aenc_seed): ciphertext.
fun skgen(keyseed):skey.
fun pkgen(keyseed):pkey.

fun injbot(cleartext):bitstringbot [data].

letfun aenc(m: cleartext, pk: pkey) =
       r <-R aenc_seed; aenc_r(m,pk,r).

(* The function Z returns for each bitstring, a bitstring
   of the same length, consisting only of zeroes. *)
fun Z(cleartext):cleartext.

(* Encryption leaks Z(m), typically the length of m *)
reduc forall m:cleartext, r:aenc_seed, pk:pkey;
        leak(aenc_r(m, pk, r)) = Z(m).
(* Note: providing a good definition of Z in ProVerif is a problem *)

fun adec(ciphertext, skey): bitstringbot
reduc forall m:cleartext, r:keyseed, r2:aenc_seed;
	adec(aenc_r(m, pkgen(r), r2), skgen(r)) = injbot(m)
otherwise forall c:ciphertext, sk: skey;
        adec(c, sk) = bottom.

(* Test equality of keys *)
reduc forall x:cleartext, x':cleartext, r:aenc_seed, r':aenc_seed, y:pkey;
        keyeq(aenc_r(x,y,r),aenc_r(x',y,r')) = true.

}

(***************************** CV_keygen ******************************)

def CV_keygen_types(key) {
	type key.
}

def CV_keygen_args(keyseed, key, kgen) {

fun kgen(keyseed): key.

}

(***************************** CV_AEAD ******************************)

def CV_AEAD_types(add_data, enc_seed, empty_add_data) {
	type add_data.
	type enc_seed.

	const empty_add_data : add_data.
}

def CV_AEAD_args(key, bitstringbot, bottom, cleartext, ciphertext, add_data, enc_seed, enc, enc_r, dec, injbot, Z) {

fun enc_r(cleartext, add_data, key, enc_seed): ciphertext.
fun injbot(cleartext):bitstringbot [data].

fun dec(ciphertext, add_data, key): bitstringbot
reduc forall m:cleartext, d:add_data, k:key, r:enc_seed;
	dec(enc_r(m, d, k, r), d, k) = injbot(m)
otherwise forall c:ciphertext, d:add_data, k:key;
        dec(c, d, k) = bottom.

fun Z(cleartext):cleartext.

(* The encryption function is probabilistic *)
letfun enc(m: cleartext, d:add_data, k: key) =
       r <-R enc_seed; enc_r(m, d, k, r).

(* The additional data is authenticated, but not encrypted, so it may leak *)
reduc forall m:cleartext, d:add_data, r:enc_seed, k:key;
        get_data(enc_r(m, d, k, r)) = d.

(* Encryption leaks Z(m), typically the length of m *)
reduc forall m:cleartext, d:add_data, r:enc_seed, k:key;
        leak(enc_r(m, d, k, r)) = Z(m).
(* Note: providing a good definition of Z in ProVerif is a problem *)

(* Test equality of keys *)
reduc forall x:cleartext, d:add_data, x':cleartext, d':add_data, r:enc_seed, r':enc_seed, y:key;
        keyeq(enc_r(x,d,y,r),enc_r(x',d',y,r')) = true.

}

(***************************** CV_Diffie-Hellman ******************************)

def CV_Diffie_Hellman_types(DiHeG, DiHeZ) {
	type DiHeG.
	type DiHeZ.
}

def CV_Diffie_Hellman_args(DiHeG, DiHeZ, DiHeValG, DiHeExp) {
	const DiHeValG : DiHeG.

	fun DiHeExp(DiHeG, DiHeZ) : DiHeG.

	equation forall x : DiHeZ, y : DiHeZ;
		DiHeExp(DiHeExp(DiHeValG, x), y) = DiHeExp(DiHeExp(DiHeValG, y), x).
}

(*****************************    CV Defs Ends   ******************************)
(*============================================================================*)

(*============================================================================*)
(*************************** DecentRA Defs Starts *****************************)

(***************************** Enclave Basics ******************************)

def Decent_Enclave_Basics(spkey, enclaveProg, enclaveHash, HashEnclave, SPKey2Bitstr, EventSubType) {
	type enclaveProg.
	type enclaveHash.

	fun HashEnclave(enclaveProg) : enclaveHash.

	fun SPKey2Bitstr(spkey) : bitstring [typeConverter].

	type EventSubType.
}

def Decent_ECDH_Key(key, ecskey, ecpkey, ecpkgen,
	DiHeG, DiHeValG, DiHeExp, EcDiHeToPKey, EcDiHeToKey, EcDiHeKeyGen) {
	(*
	ecskey = DiHeZ;
	ecpkey = DiHeExp(DiHeValG, ecskey);
	EcDiHe(ecpkey, ecskey)
	*)

	expand CV_Diffie_Hellman_types(DiHeG, ecskey).

	type ecpkey.

	expand CV_Diffie_Hellman_args (DiHeG, ecskey, DiHeValG, DiHeExp).

	fun EcDiHeToPKey(DiHeG) : ecpkey [typeConverter].
	fun EcDiHeToKey(DiHeG) : key.

	letfun ecpkgen(sk : ecskey) = EcDiHeToPKey(DiHeExp(DiHeValG, sk)).

	letfun EcDiHeKeyGen(sk : ecskey, pk : ecpkey) =
		let EcDiHeToPKey(pkVal : DiHeG) = pk in
		EcDiHeToKey(DiHeExp(pkVal, sk)).
}

(***************************** Local Attestation ******************************)

def Decent_Local_Attestation(
	(** CV_ macros  **) keyseed, sskey, spkey, sskgen, spkgen, sign, checksign, signinput, signature,
	(** Encl Basics **) enclaveProg, enclaveHash, HashEnclave, EventSubType,
	(** ECHD Key    **) ecpkey,
	(** This. Rep   **) LocAttSignedRep, ToLocAttSignedRep, LocAttRep, GetLocAttSignedRep, VrfyLocAttSignedRep) {

	type LocAttSignedRep.

	fun ToLocAttSignedRep(ecpkey, enclaveHash, bitstring, signature) : LocAttSignedRep [data].

	fun LocAttRep(ecpkey, enclaveHash, bitstring) : signinput [data].

	letfun GetLocAttSignedRep(encrPKey : ecpkey, enc : enclaveProg, appData : bitstring, repKey : sskey) =
		ToLocAttSignedRep(encrPKey, HashEnclave(enc), appData,
			sign(LocAttRep(encrPKey, HashEnclave(enc), appData), repKey)
		).

	fun VrfyLocAttSignedRep(LocAttSignedRep, spkey) : bool
		reduc forall encrPKey : ecpkey, encHash : enclaveHash, appData: bitstring, s : signature, repKeySeed : keyseed;
			VrfyLocAttSignedRep(ToLocAttSignedRep(encrPKey, encHash, appData, sign(LocAttRep(encrPKey, encHash, appData), sskgen(repKeySeed))), spkgen(repKeySeed)) = true
		otherwise forall rep : LocAttSignedRep, repKey : spkey;
			VrfyLocAttSignedRep(rep, repKey) = false.
}

(***************************** IAS report key ******************************)

def Decent_IAS_Report(
	(** CV_ macros  **) keyseed, sskey, spkey, sskgen, spkgen, sign, checksign, signinput, signature,
	(** Encl Basics **) enclaveProg, enclaveHash, HashEnclave, EventSubType,
	(** This. Vars  **) iasRepKeySeed, encPrvsKeySeed,
	(** This. Quote **) EnclaveSignedQuote, ToEnclaveSignedQuote, EnclaveQuoteSignin, GetEnclaveSignedQuote_intr, GetEnclaveSignedQuote, VrfyEnclaveSignedQuote_intr,
	(** This. Rep   **) SignedIasRep, ToSignedIasRep, IasRep2Signin, GetSignedIasRep_intr, GetSignedIasRep, VrfySignedIasRep_intr, VrfySignedIasRep,
	(** This. Proc  **) IasProcEvent, IasProc_intr) {

	const iasRepKeySeed : keyseed [private].
	(*let iasRepSSKey : sskey = sskgen(iasRepKeySeed) in*)
	(*let pub_iasRepSPKey : spkey = spkgen(iasRepKeySeed) in*)

	const encPrvsKeySeed : keyseed [private].
	(*let encPrvsKey : sskey = sskgen(encPrvsKeySeed) in*)
	(*let pub_encPrvsKey : spkey = spkgen(encPrvsKeySeed) in*)

	type EnclaveSignedQuote.

	fun ToEnclaveSignedQuote(enclaveHash, bitstring, signature) : EnclaveSignedQuote [data].

	fun EnclaveQuoteSignin(enclaveHash, bitstring) : signinput [data].

	letfun GetEnclaveSignedQuote_intr(enc : enclaveProg, appData : bitstring, prvsSSKey : sskey) =
		ToEnclaveSignedQuote(HashEnclave(enc), appData,
			sign(EnclaveQuoteSignin(HashEnclave(enc), appData), prvsSSKey)
		).

	letfun GetEnclaveSignedQuote(enc : enclaveProg, appData : bitstring) = GetEnclaveSignedQuote_intr(enc, appData, sskgen(encPrvsKeySeed)).

	fun VrfyEnclaveSignedQuote_intr(EnclaveSignedQuote, spkey) : bool
		reduc forall encHash : enclaveHash, appData: bitstring, s : signature, prvsSeed : keyseed;
			VrfyEnclaveSignedQuote_intr(ToEnclaveSignedQuote(encHash, appData, sign(EnclaveQuoteSignin(encHash, appData), sskgen(prvsSeed))), spkgen(prvsSeed)) = true
		otherwise forall quote : EnclaveSignedQuote, encPrvsKey : spkey;
			VrfyEnclaveSignedQuote_intr(quote, encPrvsKey) = false.

	type SignedIasRep.

	fun ToSignedIasRep(bool, enclaveHash, bitstring, signature): SignedIasRep [data].

	fun IasRep2Signin(bool, enclaveHash, bitstring) : signinput [data].

	letfun GetSignedIasRep_intr(res : bool, encHash : enclaveHash, appData : bitstring, iasSSKey : sskey) =
		ToSignedIasRep(res, encHash, appData,
			sign(IasRep2Signin(res, encHash, appData), iasSSKey)
		).

	letfun GetSignedIasRep(res : bool, encHash : enclaveHash, appData : bitstring) = GetSignedIasRep_intr(res, encHash, appData, sskgen(iasRepKeySeed)).

	fun VrfySignedIasRep_intr(SignedIasRep, spkey) : bool
		reduc forall res : bool, encHash : enclaveHash, appData: bitstring, s : signature, iasKeySeed : keyseed;
			VrfySignedIasRep_intr(ToSignedIasRep(res, encHash, appData, sign(IasRep2Signin(res, encHash, appData), sskgen(iasKeySeed))), spkgen(iasKeySeed)) = res
		otherwise forall iasRep : SignedIasRep, iasSPkey : spkey;
			VrfySignedIasRep_intr(iasRep, iasSPkey) = false.

	letfun VrfySignedIasRep(iasRep : SignedIasRep) = VrfySignedIasRep_intr(iasRep, spkgen(iasRepKeySeed)).

	event IasProcEvent(EventSubType).

	let IasProc_intr(iasCh : channel, iasKeySeed : keyseed, prvsPKey : spkey, accEve : EventSubType, rejEve : EventSubType) =
		in(iasCh, signedQuote : EnclaveSignedQuote);
		if VrfyEnclaveSignedQuote_intr(signedQuote, prvsPKey) then
		(
			let ToEnclaveSignedQuote(encHash : enclaveHash, appData : bitstring, quoteSign : signature) = signedQuote in
			let iasRep = GetSignedIasRep_intr(true, encHash, appData, sskgen(iasKeySeed)) in
			out(iasCh, iasRep);
			event IasProcEvent(accEve)
		)
		else
		(
			let ToEnclaveSignedQuote(encHash : enclaveHash, appData : bitstring, quoteSign : signature) = signedQuote in
			let iasRep = GetSignedIasRep_intr(false, encHash, appData, sskgen(iasKeySeed)) in
			out(iasCh, iasRep);
			event IasProcEvent(rejEve)
		).

}

(***************************** Decent Server ******************************)

def Decent_Decent_Server(
	(** CV_ macros    **) keyseed, sskey, spkey, sskgen, spkgen, sign, checksign, signinput, signature, emptyStr, key, cleartext, ciphertext, enc, dec, sinjbot, empty_add_data,
	(** Encl Basics   **) enclaveProg, enclaveHash, HashEnclave, SPKey2Bitstr,
	(** ECHD Key      **) ecskey, ecpkey, ecpkgen, EcDiHeKeyGen,
	(** LocAtt Rep    **) LocAttSignedRep, ToLocAttSignedRep, GetLocAttSignedRep, VrfyLocAttSignedRep,
	(** Ias Rep       **) encPrvsKeySeed, GetEnclaveSignedQuote_intr, SignedIasRep, ToSignedIasRep, VrfySignedIasRep_intr,
	(** Lists         **) AuthList, AuthListNewItem, AuthListIsIn,
	(** This. Vars    **) enclaveDecentSvr, decentSvrName,
	(** This. SvrCert **) DecentSvrCert, ToDecentSvrCert, DecentSvrSignin, GetDecentSvrCert, VrfyDecentSvrCert_intr,
	(** This. AppCert **) DecentAppCert, ToDecentAppCert, DecentAppSignin, GetDecentAppCert, VrfyDecentAppCertChain_intr,
	(** This. SvrProc **) DecentSvrProc_intr, DecentAppCertSignReq, DecentAppCertToCipher) {

	const enclaveDecentSvr : enclaveProg.
	const decentSvrName : bitstring.

	(*let pub_decentSvrHash : enclaveHash = HashEnclave(enclaveDecentSvr) in*)

	(* Decent App Cert *)

	type DecentSvrCert.

	fun ToDecentSvrCert(spkey, SignedIasRep, signature) : DecentSvrCert [data].

	fun DecentSvrSignin(spkey, SignedIasRep) : signinput [data].

	letfun GetDecentSvrCert(svrKeySeed : keyseed, iasRep : SignedIasRep) =
		ToDecentSvrCert(
			spkgen(svrKeySeed),
			iasRep,
			sign(DecentSvrSignin(spkgen(svrKeySeed), iasRep), sskgen(svrKeySeed))
		).

	letfun VrfyDecentSvrCert_intr(cert : DecentSvrCert, svrName : bitstring, auLs : AuthList, iasSPkey : spkey) =
		let ToDecentSvrCert(svrSPkey : spkey, iasRep : SignedIasRep, certSign : signature) = cert in
		if VrfySignedIasRep_intr(iasRep, iasSPkey) then
		(
			let ToSignedIasRep(res : bool, encHash : enclaveHash, appData: bitstring, iasSign : signature) = iasRep in
			if AuthListIsIn(AuthListNewItem(encHash, svrName), auLs) && (SPKey2Bitstr(svrSPkey) = appData) then
			(
				checksign(DecentSvrSignin(svrSPkey, iasRep), svrSPkey, certSign)
			)
			else
			(
				false
			)
		)
		else
		(
			false
		).

	(* Decent App Cert *)

	type DecentAppCert.

	fun ToDecentAppCert(enclaveHash, spkey, AuthList, signature) : DecentAppCert [data].

	fun DecentAppSignin(enclaveHash, spkey, AuthList) : signinput [data].

	letfun GetDecentAppCert(appHash : enclaveHash, appSPKey : spkey, auLs : AuthList, svrSSKey : sskey) =
		ToDecentAppCert(
			appHash,
			appSPKey,
			auLs,
			sign(DecentAppSignin(appHash, appSPKey, auLs), svrSSKey)
		).

	letfun VrfyDecentAppCertChain_intr(appCert : DecentAppCert, svrCert : DecentSvrCert, svrName : bitstring, auLs : AuthList, iasSPkey : spkey) =
		if VrfyDecentSvrCert_intr(svrCert, svrName, auLs, iasSPkey) then
		(
			let ToDecentSvrCert(svrSPKey : spkey, iasRep : SignedIasRep, svrCertSign : signature) = svrCert in
			let ToDecentAppCert(appHash : enclaveHash, appSPKey : spkey, auLs : AuthList, appCertSign : signature) = appCert in
			checksign(DecentAppSignin(appHash, appSPKey, auLs), svrSPKey, appCertSign)
		)
		else
		(
			false
		).

	fun DecentAppCertSignReq(spkey, AuthList) : cleartext [data].

	fun DecentAppCertToCipher(DecentSvrCert, DecentAppCert) : cleartext [data].

	let DecentSvrProc_intr(encProg : enclaveProg, iasCh : channel, appCh : channel, iasSPkey : spkey, prvsKeySeed : keyseed, repKeySeed : keyseed) =
		new svrKeySeed : keyseed;
		let svrSPkey = spkgen(svrKeySeed) in
		let svrSSKey = sskgen(svrKeySeed) in
		let prvsSSkey = sskgen(prvsKeySeed) in

		(* >IAS 1. Generate quote *)
		let signedQuote = GetEnclaveSignedQuote_intr(encProg, SPKey2Bitstr(svrSPkey), prvsSSkey) in
		out(iasCh, signedQuote);
		(* >IAS 2. Receive IAS Report *)
		in(iasCh, iasRep : SignedIasRep);
		if VrfySignedIasRep_intr(iasRep, iasSPkey) then
		(
			(* Successfully received valid IAS report. *)
			(* >IAS 3. Generate Decent Server Certificate. *)
			let svrCert = GetDecentSvrCert(svrKeySeed, iasRep) in

			(* >app 1. Local Attestation *)
			in(appCh, appLocAttRep : LocAttSignedRep);
			if VrfyLocAttSignedRep(appLocAttRep, spkgen(repKeySeed)) then
			(
				new svrEcSkey : ecskey;
				let svrLocAttRep = GetLocAttSignedRep(ecpkgen(svrEcSkey), encProg, emptyStr, sskgen(repKeySeed)) in
				out(appCh, svrLocAttRep);

				let ToLocAttSignedRep(appEcPKey : ecpkey, appEncHash : enclaveHash, appAppData : bitstring, appRepSign : signature) = appLocAttRep in
				let locChKey = EcDiHeKeyGen(svrEcSkey, appEcPKey) in

				(* >app 2. Generate App Certificate *)
				in(appCh, certSignReqCipher : ciphertext);
				let sinjbot(DecentAppCertSignReq(appSPkey : spkey, auLs : AuthList)) = dec(certSignReqCipher, empty_add_data, locChKey) in
				out(appCh, enc(DecentAppCertToCipher(svrCert, GetDecentAppCert(appEncHash, appSPkey, auLs, svrSSKey)), empty_add_data, locChKey))
			)
		).
}

(***************************** Decent App ******************************)

(* Certs *)

(* process (NOTE: revocation) *)

def Decent_Decent_App(
	(** CV_ macros    **) keyseed, sskey, spkey, sskgen, spkgen, sign, checksign, signinput, signature, emptyStr, key, cleartext, ciphertext, enc, dec, sinjbot, empty_add_data,
	(** Encl Basics   **) enclaveProg, enclaveHash, SPKey2Bitstr,
	(** ECHD Key      **) ecskey, ecpkey, ecpkgen, EcDiHeKeyGen,
	(** LocAtt Rep    **) LocAttSignedRep, ToLocAttSignedRep, GetLocAttSignedRep, VrfyLocAttSignedRep,
	(** Ias Rep       **) SignedIasRep, ToSignedIasRep, VrfySignedIasRep_intr,
	(** Decent Svr    **) DecentSvrCert, DecentAppCert, DecentAppCertSignReq, DecentAppCertToCipher, VrfyDecentAppCertChain_intr,
	(** Lists         **) AuthList,
	(** This. SvrProc **) DecentAppSvrProc_intr, DecentAppCltProc_intr) {

	let DecentAppSvrProc_intr(encProg : enclaveProg, svrCh : channel, peerCh : channel, iasSPkey : spkey, repKeySeed : keyseed, appKeySeed : keyseed, auLs : AuthList) =
		(* >svr 1. Local Attestation *)
		new appEcSkey : ecskey;
		let appLocAttRep = GetLocAttSignedRep(ecpkgen(appEcSkey), encProg, emptyStr, sskgen(repKeySeed)) in
		out(svrCh, appLocAttRep);
		in(svrCh, svrLocAttRep : LocAttSignedRep);
		if VrfyLocAttSignedRep(svrLocAttRep, spkgen(repKeySeed)) then
		(
			let ToLocAttSignedRep(svrEcPKey : ecpkey, svrEncHash : enclaveHash, svrAppData : bitstring, svrRepSign : signature) = svrLocAttRep in
			let locChKey = EcDiHeKeyGen(appEcSkey, svrEcPKey) in

			(* >svr 2. Request for App Certificate *)
			out(svrCh, enc(DecentAppCertSignReq(spkgen(appKeySeed), auLs), empty_add_data, locChKey));
			in(svrCh, appCertCipher : ciphertext);
			let sinjbot(DecentAppCertToCipher(svrCert : DecentSvrCert, appCert : DecentAppCert)) = dec(appCertCipher, empty_add_data, locChKey) in
			0

			(* >peer 1. Verify peer's certificate chain *)
		).

	let DecentAppCltProc_intr(encProg : enclaveProg, svrCh : channel, peerCh : channel, iasSPkey : spkey, repKeySeed : keyseed, appKeySeed : keyseed, auLs : AuthList) =
		(* >svr 1. Local Attestation *)
		new appEcSkey : ecskey;
		let appLocAttRep = GetLocAttSignedRep(ecpkgen(appEcSkey), encProg, emptyStr, sskgen(repKeySeed)) in
		out(svrCh, appLocAttRep);
		in(svrCh, svrLocAttRep : LocAttSignedRep);
		if VrfyLocAttSignedRep(svrLocAttRep, spkgen(repKeySeed)) then
		(
			let ToLocAttSignedRep(svrEcPKey : ecpkey, svrEncHash : enclaveHash, svrAppData : bitstring, svrRepSign : signature) = svrLocAttRep in
			let locChKey = EcDiHeKeyGen(appEcSkey, svrEcPKey) in

			(* >svr 2. Request for App Certificate *)
			out(svrCh, enc(DecentAppCertSignReq(spkgen(appKeySeed), auLs), empty_add_data, locChKey));
			in(svrCh, appCertCipher : ciphertext);
			let sinjbot(DecentAppCertToCipher(svrCert : DecentSvrCert, appCert : DecentAppCert)) = dec(appCertCipher, empty_add_data, locChKey) in
			0

			(* >peer 1. Verify peer's certificate chain *)
		).

(*
	type DecentVrfyAppCert.

	fun ToDecentVrfyAppCert(appName, enclaveHash, spkey, AuthList, signature) : DecentVrfyAppCert [data].

	fun DecentVrfyAppsignin(appName, enclaveHash, spkey, AuthList) : signinput [data].
*)

}

(***************************** Decent Verified App ******************************)

(* Certs *)

(* process (NOTE: revocation) *)

(***************************** Auth & Revc List ******************************)

def Decent_List(ListType, ListInsert, ListEmpty, ListIsIn, ListItem) {
	type ListType.
	fun ListInsert(ListItem, ListType) : ListType [data].
	const ListEmpty : ListType [data].

	pred ListIsIn(ListItem, ListType).
	clauses
		forall x : ListItem, y : ListType; ListIsIn(x, ListInsert(x, y));
		forall x : ListItem, y : ListType, z : ListItem; ListIsIn(x, y) -> ListIsIn(x, ListInsert(z, y)).
}

def Decent_Auth_List(enclaveHash, AuthListItem, AuthListNewItem, AuthList, AuthListInsert, AuthListEmpty, AuthListIsIn) {
	type AuthListItem.
	fun AuthListNewItem(enclaveHash, bitstring) : AuthListItem [data].

	expand Decent_List(AuthList, AuthListInsert, AuthListEmpty, AuthListIsIn, AuthListItem).
}
}

def Decent_Recv_List(enclaveHash, RecvListItem, RecvListNewItem, RecvList, RecvListInsert, RecvListEmpty, RecvListIsIn) {
	type RecvListItem.
	fun RecvListNewItem(enclaveHash) : RecvListItem [data].

	expand Decent_List(RecvList, RecvListInsert, RecvListEmpty, RecvListIsIn, RecvListItem).
}

(*************************** DecentRA Defs Ends *******************************)
(*============================================================================*)
