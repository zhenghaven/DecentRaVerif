(* This library is used for verifying DecentRA (distributed enclave application)
framework implemented with SGX.
 	Author: Haofan Zheng
*)

(* NOTE: Defs begin with CV_ are derived from cryptoverif.pvl, in order to
provide potential bridges to CryptoVerif.
	Credits to the author(s) of cryptoverif.pvl. *)

(*============================================================================*)
(*****************************   CV Defs Starts  ******************************)

(***************************** CV_Common_Declarations ******************************)

def CV_Common_Declarations(bitstringbot, bottom, emptyStr, keyseed, cleartext, ciphertext) {
	type bitstringbot.
	const bottom:bitstringbot.

	const emptyStr : bitstring.

	type keyseed.
	type cleartext.
	type ciphertext.
}

(***************************** CV_DSA ******************************)

def CV_det_signature_types(spkey, sskey, signinput, signature) {
	type sskey.
	type spkey.
	type signinput.
	type signature.
}

def CV_det_signature_args(keyseed, spkey, sskey, signinput, signature, sskgen, spkgen, sign, checksign, getmess, getkey) {

fun sign(signinput, sskey): signature.
fun sskgen(keyseed):sskey.
fun spkgen(keyseed):spkey.

fun checksign(signinput, spkey, signature): bool
reduc forall m:signinput, r:keyseed;
	checksign(m, spkgen(r), sign(m, sskgen(r))) = true
otherwise forall m: signinput, pk: spkey, s: signature;
        checksign(m, pk, s) = false.

reduc forall m:signinput, r:keyseed;
        getmess(sign(m, sskgen(r))) = m.

reduc forall m:signinput, r:keyseed;
        getkey(sign(m, sskgen(r))) = spkgen(r).

}

(***************************** CV_RSA ******************************)

def CV_public_key_enc_types(pkey, skey, aenc_seed) {
	type pkey.
	type skey.
	type aenc_seed.
}

def CV_public_key_enc_args(keyseed, bitstringbot, bottom, pkey, skey, cleartext, ciphertext, aenc_seed, skgen, pkgen, aenc, aenc_r, adec, injbot, Z) {

fun aenc_r(cleartext, pkey, aenc_seed): ciphertext.
fun skgen(keyseed):skey.
fun pkgen(keyseed):pkey.

fun injbot(cleartext):bitstringbot [data].

letfun aenc(m: cleartext, pk: pkey) =
       r <-R aenc_seed; aenc_r(m,pk,r).

(* The function Z returns for each bitstring, a bitstring
   of the same length, consisting only of zeroes. *)
fun Z(cleartext):cleartext.

(* Encryption leaks Z(m), typically the length of m *)
reduc forall m:cleartext, r:aenc_seed, pk:pkey;
        leak(aenc_r(m, pk, r)) = Z(m).
(* Note: providing a good definition of Z in ProVerif is a problem *)

fun adec(ciphertext, skey): bitstringbot
reduc forall m:cleartext, r:keyseed, r2:aenc_seed;
	adec(aenc_r(m, pkgen(r), r2), skgen(r)) = injbot(m)
otherwise forall c:ciphertext, sk: skey;
        adec(c, sk) = bottom.

(* Test equality of keys *)
reduc forall x:cleartext, x':cleartext, r:aenc_seed, r':aenc_seed, y:pkey;
        keyeq(aenc_r(x,y,r),aenc_r(x',y,r')) = true.

}

(***************************** CV_keygen ******************************)

def CV_keygen_types(key) {
	type key.
}

def CV_keygen_args(keyseed, key, kgen) {

fun kgen(keyseed): key.

}

(***************************** CV_AEAD ******************************)

def CV_AEAD_types(add_data, enc_seed, empty_add_data) {
	type add_data.
	type enc_seed.

	const empty_add_data : add_data.
}

def CV_AEAD_args(key, bitstringbot, bottom, cleartext, ciphertext, add_data, enc_seed, enc, enc_r, dec, injbot, Z) {

fun enc_r(cleartext, add_data, key, enc_seed): ciphertext.
fun injbot(cleartext):bitstringbot [data].

fun dec(ciphertext, add_data, key): bitstringbot
reduc forall m:cleartext, d:add_data, k:key, r:enc_seed;
	dec(enc_r(m, d, k, r), d, k) = injbot(m)
otherwise forall c:ciphertext, d:add_data, k:key;
        dec(c, d, k) = bottom.

fun Z(cleartext):cleartext.

(* The encryption function is probabilistic *)
letfun enc(m: cleartext, d:add_data, k: key) =
       r <-R enc_seed; enc_r(m, d, k, r).

(* The additional data is authenticated, but not encrypted, so it may leak *)
reduc forall m:cleartext, d:add_data, r:enc_seed, k:key;
        get_data(enc_r(m, d, k, r)) = d.

(* Encryption leaks Z(m), typically the length of m *)
reduc forall m:cleartext, d:add_data, r:enc_seed, k:key;
        leak(enc_r(m, d, k, r)) = Z(m).
(* Note: providing a good definition of Z in ProVerif is a problem *)

(* Test equality of keys *)
reduc forall x:cleartext, d:add_data, x':cleartext, d':add_data, r:enc_seed, r':enc_seed, y:key;
        keyeq(enc_r(x,d,y,r),enc_r(x',d',y,r')) = true.

}

(***************************** CV_Diffie-Hellman ******************************)

def CV_Diffie_Hellman_types(DiHeG, DiHeZ) {
	type DiHeG.
	type DiHeZ.
}

def CV_Diffie_Hellman_args(DiHeG, DiHeZ, DiHeValG, DiHeExp) {
	const DiHeValG : DiHeG.

	fun DiHeExp(DiHeG, DiHeZ) : DiHeG.

	equation forall x : DiHeZ, y : DiHeZ;
		DiHeExp(DiHeExp(DiHeValG, x), y) = DiHeExp(DiHeExp(DiHeValG, y), x).
}

(*****************************    CV Defs Ends   ******************************)
(*============================================================================*)

(*============================================================================*)
(*************************** DecentRA Defs Starts *****************************)

(***************************** Enclave Basics ******************************)

def Decent_Enclave_Basics(spkey, cleartext, enclaveProg, enclaveHash, HashEnclave, SPKey2Bitstr, Bit2Cleartext, EventSubType) {
	type enclaveProg.
	type enclaveHash.

	fun HashEnclave(enclaveProg) : enclaveHash.

	fun SPKey2Bitstr(spkey) : bitstring [typeConverter].
	fun Bit2Cleartext(bitstring) : cleartext [typeConverter].

	type EventSubType.
}

def Decent_ECDH_Key(key, ecskey, ecpkey, ecpkgen, signinput,
	DiHeValG, DiHeExp, EcDiHeToKey, EcDiHeKeyGen, EcPKeyToSignin) {
	(*
	ecskey = DiHeZ;
	ecpkey = DiHeExp(DiHeValG, ecskey);
	EcDiHe(ecpkey, ecskey)
	*)

	expand CV_Diffie_Hellman_types(ecpkey, ecskey).

	expand CV_Diffie_Hellman_args (ecpkey, ecskey, DiHeValG, DiHeExp).

	fun EcDiHeToKey(ecpkey) : key.

	letfun ecpkgen(sk : ecskey) = DiHeExp(DiHeValG, sk).

	letfun EcDiHeKeyGen(sk : ecskey, pk : ecpkey) = EcDiHeToKey(DiHeExp(pk, sk)).

	fun EcPKeyToSignin(ecpkey) : signinput [typeConverter].
}

(***************************** Local Attestation ******************************)

def Decent_Local_Attestation(
	(** CV_ macros  **) keyseed, sskey, spkey, sign, signinput, signature,
	(** Encl Basics **) enclaveProg, enclaveHash, HashEnclave,
	(** ECHD Key    **) ecpkey,
	(** This. Rep   **) LocAttRep, GetLocAttSignedRep) {

	fun LocAttRep(ecpkey, enclaveHash, bitstring) : signinput [data].

	letfun GetLocAttSignedRep(encrPKey : ecpkey, enc : enclaveProg, appData : bitstring, repKey : sskey) = sign(LocAttRep(encrPKey, HashEnclave(enc), appData), repKey).

}

(***************************** IAS report key ******************************)

def Decent_IAS_Report(
	(** CV_ macros  **) keyseed, sskey, spkey, sskgen, spkgen, sign, getmess, checksign, signinput, signature,
	(** Encl Basics **) enclaveProg, enclaveHash, HashEnclave,
	(** This. Vars  **) iasRepKeySeed, encPrvsKeySeed,
	(** This. Quote **) EnclaveQuoteSignin, GetEnclaveSignedQuote_intr, GetEnclaveSignedQuote,
	(** This. Rep   **) IasRep2Signin, GetSignedIasRep_intr, GetSignedIasRep,
	(** This. Proc  **) IasIssueRep, IasProc_intr) {

	const iasRepKeySeed : keyseed [private].
	(*let iasRepSSKey : sskey = sskgen(iasRepKeySeed) in*)
	(*let pub_iasRepSPKey : spkey = spkgen(iasRepKeySeed) in*)

	const encPrvsKeySeed : keyseed [private].
	(*let encPrvsKey : sskey = sskgen(encPrvsKeySeed) in*)
	(*let pub_encPrvsKey : spkey = spkgen(encPrvsKeySeed) in*)

	type EnclaveSignedQuote.

	fun EnclaveQuoteSignin(enclaveHash, bitstring) : signinput [data].

	letfun GetEnclaveSignedQuote_intr(enc : enclaveProg, appData : bitstring, prvsSSKey : sskey) = sign(EnclaveQuoteSignin(HashEnclave(enc), appData), prvsSSKey).

	letfun GetEnclaveSignedQuote(enc : enclaveProg, appData : bitstring) = GetEnclaveSignedQuote_intr(enc, appData, sskgen(encPrvsKeySeed)).

	fun IasRep2Signin(bool, enclaveHash, bitstring) : signinput [data].

	letfun GetSignedIasRep_intr(res : bool, encHash : enclaveHash, appData : bitstring, iasSSKey : sskey) = sign(IasRep2Signin(res, encHash, appData), iasSSKey).

	letfun GetSignedIasRep(res : bool, encHash : enclaveHash, appData : bitstring) = GetSignedIasRep_intr(res, encHash, appData, sskgen(iasRepKeySeed)).

	event IasIssueRep(keyseed, bool, enclaveHash, bitstring).

	let IasProc_intr(iasCh : channel, iasKeySeed : keyseed, prvsPKey : spkey) =
		in(iasCh, signedQuote : signature);
		let quoteCheckRes = checksign(getmess(signedQuote), prvsPKey, signedQuote) in
		let EnclaveQuoteSignin(encHash : enclaveHash, appData : bitstring) = getmess(signedQuote) in
		let iasRep = GetSignedIasRep_intr(quoteCheckRes, encHash, appData, sskgen(iasKeySeed)) in
		out(iasCh, iasRep);
		event IasIssueRep(iasKeySeed, quoteCheckRes, encHash, appData).

}

(***************************** Decent Server ******************************)

def Decent_Decent_Server(
	(** CV_ macros    **) keyseed, sskey, spkey, sskgen, spkgen, getmess, sign, checksign, signinput, signature, emptyStr, key, cleartext, ciphertext, enc, dec, sinjbot, empty_add_data,
	(** Encl Basics   **) enclaveProg, enclaveHash, HashEnclave, SPKey2Bitstr, Bit2Cleartext,
	(** ECHD Key      **) ecskey, ecpkey, ecpkgen, EcDiHeKeyGen,
	(** LocAtt Rep    **) LocAttRep, GetLocAttSignedRep,
	(** Ias Rep       **) encPrvsKeySeed, GetEnclaveSignedQuote_intr, IasRep2Signin,
	(** Lists         **) AuthList, AuthListNewItem, AuthListIsIn,
	(** This. Vars    **) enclaveDecentSvr, decentSvrName,
	(** This. SvrCert **) DecentSvrSignin, GetDecentSvrCert, VrfyDecentSvrCert_intr,
	(** This. AppCert **) DecentAppSignin, GetDecentAppCert, VrfyDecentAppCertChain_intr,
	(** This. SvrProc **) DecentSvrIssueCert, DecentSvrGotIasRep, DecentSvrProc_intr, DecentSvrProcP2_intr) {

	const enclaveDecentSvr : enclaveProg.
	const decentSvrName : bitstring.

	event DecentSvrIssueCert(enclaveProg, enclaveHash, keyseed, spkey, AuthList).
	event DecentSvrGotIasRep(enclaveProg, spkey).

	(*let pub_decentSvrHash : enclaveHash = HashEnclave(enclaveDecentSvr) in*)

	(* Decent App Cert *)

	fun DecentSvrSignin(spkey, signature) : signinput [data].

	letfun GetDecentSvrCert(svrKeySeed : keyseed, iasRep : signature) = sign(DecentSvrSignin(spkgen(svrKeySeed), iasRep), sskgen(svrKeySeed)).

	letfun VrfyDecentSvrCert_intr(svrCert : signature, svrName : bitstring, auLs : AuthList, iasSPkey : spkey) =
		let DecentSvrSignin(svrSPkey : spkey, iasRep : signature) = getmess(svrCert) in
		let IasRep2Signin(iasRes : bool, encHash : enclaveHash, appData: bitstring) = getmess(iasRep) in
		checksign(getmess(iasRep), iasSPkey, iasRep) &&
			iasRes &&
			AuthListIsIn(AuthListNewItem(encHash, svrName), auLs) &&
			(SPKey2Bitstr(svrSPkey) = appData) &&
			checksign(getmess(svrCert), svrSPkey, svrCert).

	(* Decent App Cert *)

	fun DecentAppSignin(enclaveHash, spkey, AuthList) : signinput [data].

	letfun GetDecentAppCert(appHash : enclaveHash, appSPKey : spkey, auLs : AuthList, svrSSKey : sskey) = sign(DecentAppSignin(appHash, appSPKey, auLs), svrSSKey).

	letfun VrfyDecentAppCertChain_intr(peerAppCert : signature, peerSvrCert : signature, iasSPkey : spkey, svrName : bitstring, expAppName : bitstring, auLs : AuthList) =
		let DecentSvrSignin(peerSvrSPKey : spkey, peerIasRep : signature) = getmess(peerSvrCert) in
		let DecentAppSignin(peerHash : enclaveHash, peerSPKey : spkey, peerAuLs : AuthList) = getmess(peerAppCert) in
		VrfyDecentSvrCert_intr(peerSvrCert, svrName, auLs, iasSPkey) &&
			checksign(getmess(peerAppCert), peerSvrSPKey, peerAppCert) &&
			(auLs = peerAuLs) &&
			AuthListIsIn(AuthListNewItem(peerHash, expAppName), auLs).

	let DecentSvrProcP2_intr(encProg : enclaveProg, appCh : channel, iasRep : signature, svrKeySeed : keyseed, repKeySeed : keyseed) =
		let svrCert = GetDecentSvrCert(svrKeySeed, iasRep) in
		(* >app 1. Local Attestation *)
		in(appCh, appLocAttRep : signature);
		if checksign(getmess(appLocAttRep), spkgen(repKeySeed), appLocAttRep) then
		(
			new svrEcSkey : ecskey;
			let svrLocAttRep = GetLocAttSignedRep(ecpkgen(svrEcSkey), encProg, emptyStr, sskgen(repKeySeed)) in
			out(appCh, svrLocAttRep);

			let LocAttRep(appEcPKey : ecpkey, appEncHash : enclaveHash, appAppData : bitstring) = getmess(appLocAttRep) in
			let locChKey = EcDiHeKeyGen(svrEcSkey, appEcPKey) in

			(* >app 2. Generate App Certificate *)
			in(appCh, certSignReqCipher : ciphertext);
			let sinjbot(Bit2Cleartext((appSPkey : spkey, auLs : AuthList))) = dec(certSignReqCipher, empty_add_data, locChKey) in
			out(appCh, enc(Bit2Cleartext((svrCert, GetDecentAppCert(appEncHash, appSPkey, auLs, sskgen(svrKeySeed)))), empty_add_data, locChKey));

			event DecentSvrIssueCert(encProg, appEncHash, repKeySeed, appSPkey, auLs)
			(*sync 2*)
		).

	let DecentSvrProc_intr(encProg : enclaveProg, svrKeySeed : keyseed, iasCh : channel, appCh : channel, iasSPkey : spkey, prvsKeySeed : keyseed, repKeySeed : keyseed) =
		(* >IAS 1. Generate quote *)
		let signedQuote = GetEnclaveSignedQuote_intr(encProg, SPKey2Bitstr(spkgen(svrKeySeed)), sskgen(prvsKeySeed)) in
		out(iasCh, signedQuote);
		(* >IAS 2. Receive IAS Report *)
		in(iasCh, iasRep : signature);

		let IasRep2Signin(iasRes : bool, iasRepEncHash : enclaveHash, iasRepAppData: bitstring) = getmess(iasRep) in
		if checksign(getmess(iasRep), iasSPkey, iasRep) && iasRes then
		(
			(* Successfully received valid IAS report. *)
			event DecentSvrGotIasRep(encProg, iasSPkey);
			(*sync 1;*)
			DecentSvrProcP2_intr(encProg, appCh, iasRep, svrKeySeed, repKeySeed)
		).
}

(***************************** Decent App ******************************)

(* Certs *)

(* process (NOTE: revocation) *)

def Decent_Decent_App(
	(** CV_ macros    **) keyseed, sskey, spkey, sskgen, spkgen, getmess, sign, checksign, signinput, signature, emptyStr, key, cleartext, ciphertext, enc, dec, sinjbot, empty_add_data,
	(** Encl Basics   **) enclaveProg, enclaveHash, SPKey2Bitstr, Bit2Cleartext, EventSubType,
	(** ECHD Key      **) ecskey, ecpkey, ecpkgen, EcDiHeKeyGen, EcPKeyToSignin,
	(** LocAtt Rep    **) LocAttRep, GetLocAttSignedRep,
	(** Decent Svr    **) DecentAppSignin, VrfyDecentAppCertChain_intr,
	(** Lists         **) AuthList,
	(** This. AppProc **) DecentAppAccPeer, DecentAppGotCert, DecentAppGotMsg, DecentAppSvrProc_intr, DecentAppCltProc_intr, DecentAppSvrProcP2_intr, DecentAppCltProcP2_intr) {
	event DecentAppGotMsg(enclaveProg, bitstring).
	event DecentAppGotCert(enclaveProg, enclaveHash, keyseed).
	event DecentAppAccPeer(enclaveProg, enclaveHash).

	let DecentAppSvrProcP2_intr(encProg : enclaveProg, peerCh : channel, isPeerVrfy : bool,
		iasSPkey : spkey, appKeySeed : keyseed, svrName : bitstring, peerName : bitstring, auLs : AuthList,
		svrCert : signature, appCert : signature) =
		(*sync 2;*)
		(* >peer 1. Verify peer's certificate chain *)
		if not(isPeerVrfy) then
		(
			in(peerCh, (peerEcPKey : ecpkey, peerEcKeySign : signature, peerSvrCert : signature, peerCert : signature));
			let DecentAppSignin(peerHash : enclaveHash, peerSPKey : spkey, peerAuLs : AuthList) = getmess(peerCert) in
			if VrfyDecentAppCertChain_intr(peerCert, peerSvrCert, iasSPkey, svrName, peerName, auLs) &&
				checksign(EcPKeyToSignin(peerEcPKey), peerSPKey, peerEcKeySign) then
			(
				event DecentAppAccPeer(encProg, peerHash);

				new myEcSKey : ecskey;
				out(peerCh, (ecpkgen(myEcSKey), sign(EcPKeyToSignin(ecpkgen(myEcSKey)), sskgen(appKeySeed)), svrCert, appCert));

				(* >peer 2. Calc shared secret *)
				let peerChKey = EcDiHeKeyGen(myEcSKey, peerEcPKey) in

				(* >peer 3. Recv secret from client *)
				in(peerCh, cipherMsg : ciphertext);
				let sinjbot(Bit2Cleartext(msg : bitstring)) = dec(cipherMsg, empty_add_data, peerChKey) in
				event DecentAppGotMsg(encProg, msg)
			)
		).

	let DecentAppSvrProc_intr(encProg : enclaveProg, svrCh : channel, peerCh : channel, isPeerVrfy : bool,
		iasSPkey : spkey, repKeySeed : keyseed, appKeySeed : keyseed, svrName : bitstring, peerName : bitstring, auLs : AuthList) =

		(*sync 1;*)
		(* >svr 1. Local Attestation *)
		new appEcSkey : ecskey;
		let appLocAttRep = GetLocAttSignedRep(ecpkgen(appEcSkey), encProg, emptyStr, sskgen(repKeySeed)) in
		out(svrCh, appLocAttRep);
		in(svrCh, svrLocAttRep : signature);
		if checksign(getmess(svrLocAttRep), spkgen(repKeySeed), svrLocAttRep) then
		(
			let LocAttRep(svrEcPKey : ecpkey, svrEncHash : enclaveHash, svrAppData : bitstring) = getmess(svrLocAttRep) in
			let locChKey = EcDiHeKeyGen(appEcSkey, svrEcPKey) in

			(* >svr 2. Request for App Certificate *)
			out(svrCh, enc(Bit2Cleartext((spkgen(appKeySeed), auLs)), empty_add_data, locChKey));
			in(svrCh, appCertCipher : ciphertext);
			let sinjbot(Bit2Cleartext((svrCert : signature, appCert : signature))) = dec(appCertCipher, empty_add_data, locChKey) in
			event DecentAppGotCert(encProg, svrEncHash, appKeySeed);

			DecentAppSvrProcP2_intr(encProg, peerCh, isPeerVrfy, iasSPkey, appKeySeed, svrName, peerName, auLs,
				svrCert, appCert)
		).

	let DecentAppCltProcP2_intr(encProg : enclaveProg, peerCh : channel, isPeerVrfy : bool, msg : bitstring,
		iasSPkey : spkey, appKeySeed : keyseed, svrName : bitstring, peerName : bitstring, auLs : AuthList,
		svrCert : signature, appCert : signature) =
		(*sync 2;*)
		(* >peer 1. Verify peer's certificate chain *)
		new myEcSKey : ecskey;
		out(peerCh, (ecpkgen(myEcSKey), sign(EcPKeyToSignin(ecpkgen(myEcSKey)), sskgen(appKeySeed)), svrCert, appCert));
		if not(isPeerVrfy) then
		(
			in(peerCh, (peerEcPKey : ecpkey, peerEcKeySign : signature, peerSvrCert : signature, peerCert : signature));
			let DecentAppSignin(peerHash : enclaveHash, peerSPKey : spkey, peerAuLs : AuthList) = getmess(peerCert) in
			if VrfyDecentAppCertChain_intr(peerCert, peerSvrCert, iasSPkey, svrName, peerName, auLs) &&
				checksign(EcPKeyToSignin(peerEcPKey), peerSPKey, peerEcKeySign) then
			(
				event DecentAppAccPeer(encProg, peerHash);

				(* >peer 2. Calc shared secret *)
				let peerChKey = EcDiHeKeyGen(myEcSKey, peerEcPKey) in

				(* >peer 3. Send secret to server *)
				out(peerCh, enc(Bit2Cleartext(msg), empty_add_data, peerChKey))
			)
		).

	let DecentAppCltProc_intr(encProg : enclaveProg, svrCh : channel, peerCh : channel, isPeerVrfy : bool, msg : bitstring,
		iasSPkey : spkey, repKeySeed : keyseed, appKeySeed : keyseed, svrName : bitstring, peerName : bitstring, auLs : AuthList) =

		(*sync 1;*)
		(* >svr 1. Local Attestation *)
		new appEcSkey : ecskey;
		let appLocAttRep = GetLocAttSignedRep(ecpkgen(appEcSkey), encProg, emptyStr, sskgen(repKeySeed)) in
		out(svrCh, appLocAttRep);
		in(svrCh, svrLocAttRep : signature);
		if checksign(getmess(svrLocAttRep), spkgen(repKeySeed), svrLocAttRep) then
		(
			let LocAttRep(svrEcPKey : ecpkey, svrEncHash : enclaveHash, svrAppData : bitstring) = getmess(svrLocAttRep) in
			let locChKey = EcDiHeKeyGen(appEcSkey, svrEcPKey) in

			(* >svr 2. Request for App Certificate *)
			out(svrCh, enc(Bit2Cleartext((spkgen(appKeySeed), auLs)), empty_add_data, locChKey));
			in(svrCh, appCertCipher : ciphertext);
			let sinjbot(Bit2Cleartext((svrCert : signature, appCert : signature))) = dec(appCertCipher, empty_add_data, locChKey) in

			DecentAppCltProcP2_intr(encProg, peerCh, isPeerVrfy, msg, iasSPkey, appKeySeed, svrName, peerName, auLs,
				svrCert, appCert)
		).

(*
	type DecentVrfyAppCert.

	fun ToDecentVrfyAppCert(appName, enclaveHash, spkey, AuthList, signature) : DecentVrfyAppCert [data].

	fun DecentVrfyAppsignin(appName, enclaveHash, spkey, AuthList) : signinput [data].
*)

}

(***************************** Decent Verified App ******************************)

(* Certs *)

(* process (NOTE: revocation) *)

(***************************** Auth & Revc List ******************************)

def Decent_List(ListType, ListInsert, ListEmpty, ListIsIn, ListItem) {
	type ListType.
	const ListEmpty : ListType [data].

	fun ListInsert(ListItem, ListType) : ListType [data].
	pred ListIsIn(ListItem, ListType).
	clauses
		forall x : ListItem, y : ListType; ListIsIn(x, ListInsert(x, y));
		forall x : ListItem, y : ListType, z : ListItem; ListIsIn(x, y) -> ListIsIn(x, ListInsert(z, y)).
}

def Decent_Auth_List(enclaveHash, AuthListItem, AuthListNewItem, AuthList, AuthListInsert, AuthListEmpty, AuthListIsIn) {
	type AuthListItem.
	fun AuthListNewItem(enclaveHash, bitstring) : AuthListItem [data].

	expand Decent_List(AuthList, AuthListInsert, AuthListEmpty, AuthListIsIn, AuthListItem).
}
}

def Decent_Recv_List(enclaveHash, RecvListItem, RecvListNewItem, RecvList, RecvListInsert, RecvListEmpty, RecvListIsIn) {
	type RecvListItem.
	fun RecvListNewItem(enclaveHash) : RecvListItem [data].

	expand Decent_List(RecvList, RecvListInsert, RecvListEmpty, RecvListIsIn, RecvListItem).
}

(*************************** DecentRA Defs Ends *******************************)
(*============================================================================*)
