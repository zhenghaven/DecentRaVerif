(* This library is used for verifying DecentRA (distributed enclave application)
framework implemented with SGX.
 	Author: Haofan Zheng
*)

(* NOTE: Defs begin with CV_ are derived from cryptoverif.pvl, in order to
provide potential bridges to CryptoVerif.
	Credits to the author(s) of cryptoverif.pvl. *)

(*============================================================================*)
(*****************************   CV Defs Starts  ******************************)

(***************************** CV_Common_Declarations ******************************)

def CV_Common_Declarations(bitstringbot, bottom, keyseed, cleartext, ciphertext) {
	type bitstringbot.
	const bottom:bitstringbot.

	type keyseed.
	type cleartext.
	type ciphertext.
}

(***************************** CV_DSA ******************************)

def CV_det_signature_types(spkey, sskey, signinput, signature) {
	type sskey.
	type spkey.
	type signinput.
	type signature.
}

def CV_det_signature_args(keyseed, spkey, sskey, signinput, signature, sskgen, spkgen, sign, checksign) {

fun sign(signinput, sskey): signature.
fun sskgen(keyseed):sskey.
fun spkgen(keyseed):spkey.

fun checksign(signinput, spkey, signature): bool
reduc forall m:signinput, r:keyseed;
	checksign(m, spkgen(r), sign(m, sskgen(r))) = true
otherwise forall m: signinput, pk: spkey, s: signature;
        checksign(m, pk, s) = false.

reduc forall m:signinput, r:keyseed;
        getmess(sign(m, sskgen(r))) = m.

reduc forall m:signinput, r:keyseed;
        getkey(sign(m, sskgen(r))) = spkgen(r).

}

(***************************** CV_RSA ******************************)

def CV_public_key_enc_types(pkey, skey, aenc_seed) {
	type pkey.
	type skey.
	type aenc_seed.
}

def CV_public_key_enc_args(keyseed, bitstringbot, bottom, pkey, skey, cleartext, ciphertext, aenc_seed, skgen, pkgen, aenc, aenc_r, adec, injbot, Z) {

fun aenc_r(cleartext, pkey, aenc_seed): ciphertext.
fun skgen(keyseed):skey.
fun pkgen(keyseed):pkey.

fun injbot(cleartext):bitstringbot [data].

letfun aenc(m: cleartext, pk: pkey) =
       r <-R aenc_seed; aenc_r(m,pk,r).

(* The function Z returns for each bitstring, a bitstring
   of the same length, consisting only of zeroes. *)
fun Z(cleartext):cleartext.

(* Encryption leaks Z(m), typically the length of m *)
reduc forall m:cleartext, r:aenc_seed, pk:pkey;
        leak(aenc_r(m, pk, r)) = Z(m).
(* Note: providing a good definition of Z in ProVerif is a problem *)

fun adec(ciphertext, skey): bitstringbot
reduc forall m:cleartext, r:keyseed, r2:aenc_seed;
	adec(aenc_r(m, pkgen(r), r2), skgen(r)) = injbot(m)
otherwise forall c:ciphertext, sk: skey;
        adec(c, sk) = bottom.

(* Test equality of keys *)
reduc forall x:cleartext, x':cleartext, r:aenc_seed, r':aenc_seed, y:pkey;
        keyeq(aenc_r(x,y,r),aenc_r(x',y,r')) = true.

}

(***************************** CV_keygen ******************************)

def CV_keygen_types(key) {
	type key.
}

def CV_keygen_args(keyseed, key, kgen) {

fun kgen(keyseed): key.

}

(***************************** CV_AEAD ******************************)

def CV_AEAD_types(add_data, enc_seed) {
	type add_data.
	type enc_seed.
}

def CV_AEAD_args(key, bitstringbot, bottom, cleartext, ciphertext, add_data, enc_seed, enc, enc_r, dec, injbot, Z) {

fun enc_r(cleartext, add_data, key, enc_seed): ciphertext.
fun injbot(cleartext):bitstringbot [data].

fun dec(ciphertext, add_data, key): bitstringbot
reduc forall m:cleartext, d:add_data, k:key, r:enc_seed;
	dec(enc_r(m, d, k, r), d, k) = injbot(m)
otherwise forall c:ciphertext, d:add_data, k:key;
        dec(c, d, k) = bottom.

fun Z(cleartext):cleartext.

(* The encryption function is probabilistic *)
letfun enc(m: cleartext, d:add_data, k: key) =
       r <-R enc_seed; enc_r(m, d, k, r).

(* The additional data is authenticated, but not encrypted, so it may leak *)
reduc forall m:cleartext, d:add_data, r:enc_seed, k:key;
        get_data(enc_r(m, d, k, r)) = d.

(* Encryption leaks Z(m), typically the length of m *)
reduc forall m:cleartext, d:add_data, r:enc_seed, k:key;
        leak(enc_r(m, d, k, r)) = Z(m).
(* Note: providing a good definition of Z in ProVerif is a problem *)

(* Test equality of keys *)
reduc forall x:cleartext, d:add_data, x':cleartext, d':add_data, r:enc_seed, r':enc_seed, y:key;
        keyeq(enc_r(x,d,y,r),enc_r(x',d',y,r')) = true.

}

(*****************************    CV Defs Ends   ******************************)
(*============================================================================*)

(*============================================================================*)
(*************************** DecentRA Defs Starts *****************************)

(***************************** Enclave Basics ******************************)

def Decent_Enclave_Basics_types(enclaveProg, enclaveHash) {
	type enclaveProg.
	type enclaveHash.
}

def Decent_Enclave_Basics_args(enclaveProg, enclaveHash, HashEnclave, SPKey2Bitstr, spkey) {
	fun HashEnclave(enclaveProg) : enclaveHash.

	fun SPKey2Bitstr(spkey) : bitstring [typeConverter].
}

(***************************** IAS report key ******************************)

def Decent_IAS_Report_args(keyseed, sskgen, spkgen, sign, checksign, signinput, signature,
	enclaveProg, enclaveHash, HashEnclave,
	iasRepKeySeed, SignedIasRep, ToSignedIasRep, IasRep2Signin, GetSignedIasRep, VrfySignedIasRep, SignedIasRepGetEncHash, SignedIasRepGetAppData) {
	free iasRepKeySeed : keyseed [private].

	(*let iasRepSSKey : sskey = sskgen(iasRepKeySeed) in*)
	(*let pub_iasRepSPKey : spkey = spkgen(iasRepKeySeed) in*)

	type SignedIasRep.

	fun ToSignedIasRep(enclaveHash, bitstring, signature): SignedIasRep [data].

	fun IasRep2Signin(enclaveHash, bitstring) : signinput [data].

	letfun GetSignedIasRep(enc : enclaveProg, appData : bitstring) =
		ToSignedIasRep(HashEnclave(enc), appData,
			sign(IasRep2Signin(HashEnclave(enc), appData), sskgen(iasRepKeySeed))
		).

	letfun VrfySignedIasRep(iasRep : SignedIasRep) =
		let ToSignedIasRep(encHash : enclaveHash, appData: bitstring, s : signature) = iasRep in
		checksign(IasRep2Signin(encHash, appData), spkgen(iasRepKeySeed), s).

	reduc forall encHash : enclaveHash, appData: bitstring, s : signature;
		SignedIasRepGetEncHash(ToSignedIasRep(encHash, appData, s)) = encHash.

	reduc forall encHash : enclaveHash, appData: bitstring, s : signature;
		SignedIasRepGetAppData(ToSignedIasRep(encHash, appData, s)) = appData.
}

(***************************** Decent Server ******************************)

def Decent_Decent_Server_args(keyseed, sskgen, spkgen, sign, checksign, signinput, signature, spkey,
	enclaveProg, SignedIasRep, GetSignedIasRep, SPKey2Bitstr, HashEnclave, VrfySignedIasRep, SignedIasRepGetEncHash, SignedIasRepGetAppData,
	enclaveDecentSvr, DecentSvrCert, ToDecentSvrCert, DecentSvrSignin, GetDecentSvrCert, VrfyDecentSvrCert, DecentSvrCertGetSPKey) {
	free enclaveDecentSvr : enclaveProg [private].

	(*let pub_decentSvrHash : enclaveHash = HashEnclave(enclaveDecentSvr) in*)

	type DecentSvrCert.

	fun ToDecentSvrCert(spkey, SignedIasRep, signature) : DecentSvrCert [data].

	fun DecentSvrSignin(spkey, SignedIasRep) : signinput [data].

	letfun GetDecentSvrCert() =
		new svrKeySeed : keyseed;
		let sk = spkgen(svrKeySeed) in
		let iasRep = GetSignedIasRep(enclaveDecentSvr, SPKey2Bitstr(spkgen(svrKeySeed))) in
		ToDecentSvrCert(
			sk,
			iasRep,
			sign(DecentSvrSignin(sk, iasRep), sskgen(svrKeySeed))
		).

	letfun VrfyDecentSvrCert(cert : DecentSvrCert) =
		let ToDecentSvrCert(spk : spkey, iasRep : SignedIasRep, s : signature) = cert in
		if VrfySignedIasRep(iasRep) then
		(
			if (HashEnclave(enclaveDecentSvr) = SignedIasRepGetEncHash(iasRep)) && (SPKey2Bitstr(spk) = SignedIasRepGetAppData(iasRep)) then
			(
				checksign(DecentSvrSignin(spk, iasRep), spk, s)
			)
			else
			(
				false
			)
		)
		else
		(
			false
		).

	reduc forall spk : spkey, iasRep : SignedIasRep, s : signature;
		DecentSvrCertGetSPKey(ToDecentSvrCert(spk, iasRep, s)) = spk.
}

(***************************** Auth List ******************************)

def Decent_Auth_List(AuthListItem, AuthListNewItem, AuthList, AuthListInsert, AuthListEmpty, AuthListIsIn, enclaveHash) {
	type AuthListItem.
	fun AuthListNewItem(enclaveHash, bitstring) : AuthListItem [data].

	type AuthList.
	fun AuthListInsert(AuthListItem, AuthList) : AuthList [data].
	const AuthListEmpty : AuthList [data].

	pred AuthListIsIn(AuthListItem, AuthList).
	clauses
		forall x : AuthListItem, y : AuthList; AuthListIsIn(x, AuthListInsert(x, y));
		forall x : AuthListItem, y : AuthList, z : AuthListItem; AuthListIsIn(x, y) -> AuthListIsIn(x, AuthListInsert(z, y)).
}

(*************************** DecentRA Defs Ends *******************************)
(*============================================================================*)
